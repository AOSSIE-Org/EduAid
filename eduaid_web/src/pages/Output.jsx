import React, { useState, useEffect } from "react";
import { PDFDocument, rgb } from "pdf-lib";
import "../index.css";
import logo from "../assets/aossie_logo.png";
import logoPNG from "../assets/aossie_logo_transparent.png";

const Output = () => {
  const [qaPairs, setQaPairs] = useState([]);
  const [questionType, setQuestionType] = useState(
    localStorage.getItem("selectedQuestionType")
  );
  const [canvasForm, setCanvasForm] = useState({
    courseId: "",
    title: "EduAid Generated Quiz",
    description: "Generated by EduAid",
  });
  const [quizUrl, setQuizUrl] = useState("");
  const [pdfMode, setPdfMode] = useState("questions");
  const [courseId, setCourseId] = useState(""); // New state for Canvas course ID
  const [exportStatus, setExportStatus] = useState(""); // Status feedback for Canvas export

  const handleCanvasFormChange = (e) => {
    const { name, value } = e.target;
    setCanvasForm((prev) => ({ ...prev, [name]: value }));
  };

  useEffect(() => {
    const handleClickOutside = (event) => {
      const dropdown = document.getElementById("pdfDropdown");
      if (
        dropdown &&
        !dropdown.contains(event.target) &&
        !event.target.closest("button")
      ) {
        dropdown.classList.add("hidden");
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  useEffect(() => {
    const qaPairsFromStorage =
      JSON.parse(localStorage.getItem("qaPairs")) || {};
    if (qaPairsFromStorage) {
      const combinedQaPairs = [];

      if (qaPairsFromStorage["output_boolq"]) {
        qaPairsFromStorage["output_boolq"]["Boolean_Questions"].forEach(
          (question, index) => {
            combinedQaPairs.push({
              question,
              question_type: "Boolean",
              context: qaPairsFromStorage["output_boolq"]["Text"],
            });
          }
        );
      }

      if (qaPairsFromStorage["output_mcq"]) {
        qaPairsFromStorage["output_mcq"]["questions"].forEach((qaPair) => {
          combinedQaPairs.push({
            question: qaPair.question_statement,
            question_type: "MCQ",
            options: qaPair.options,
            answer: qaPair.answer,
            context: qaPair.context,
          });
        });
      }

      if (qaPairsFromStorage["output_mcq"] || questionType === "get_mcq") {
        qaPairsFromStorage["output"].forEach((qaPair) => {
          combinedQaPairs.push({
            question: qaPair.question_statement,
            question_type: "MCQ",
            options: qaPair.options,
            answer: qaPair.answer,
            context: qaPair.context,
          });
        });
      }

      if (questionType == "get_boolq") {
        qaPairsFromStorage["output"].forEach((qaPair) => {
          combinedQaPairs.push({
            question: qaPair,
            question_type: "Boolean",
          });
        });
      } else if (qaPairsFromStorage["output"] && questionType !== "get_mcq") {
        qaPairsFromStorage["output"].forEach((qaPair) => {
          combinedQaPairs.push({
            question:
              qaPair.question || qaPair.question_statement || qaPair.Question,
            options: qaPair.options,
            answer: qaPair.answer || qaPair.Answer,
            context: qaPair.context,
            question_type: "Short",
          });
        });
      }

      setQaPairs(combinedQaPairs);
    }
  }, []);

  const generateGoogleForm = async () => {
    const response = await fetch(
      `${process.env.REACT_APP_BASE_URL}/generate_gform`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          qa_pairs: qaPairs,
          question_type: questionType,
        }),
      }
    );

    if (response.ok) {
      const result = await response.json();
      const formUrl = result.form_link;
      window.open(formUrl, "_blank");
    } else {
      console.error("Failed to generate Google Form");
    }
  };

  const loadLogoAsBytes = async () => {
    try {
      const response = await fetch(logoPNG);
      const arrayBuffer = await response.arrayBuffer();
      return new Uint8Array(arrayBuffer);
    } catch (error) {
      console.error("Error loading logo:", error);
      return null;
    }
  };

  const generatePDF = async (mode) => {
    const pageWidth = 595.28;
    const pageHeight = 841.89;
    const margin = 50;
    const maxContentWidth = pageWidth - 2 * margin;
    const maxContentHeight = pageHeight - 2 * margin;

    const pdfDoc = await PDFDocument.create();
    let page = pdfDoc.addPage([pageWidth, pageHeight]);
    const d = new Date(Date.now());

    const logoBytes = await loadLogoAsBytes();
    let logoImage;
    if (logoBytes) {
      try {
        logoImage = await pdfDoc.embedPng(logoBytes);
        const logoDims = logoImage.scale(0.2);
        page.drawImage(logoImage, {
          x: margin,
          y: pageHeight - margin - 30,
          width: logoDims.width,
          height: logoDims.height,
        });
        page.drawText("EduAid generated Quiz", {
          x: margin + logoDims.width + 10,
          y: pageHeight - margin,
          size: 20,
        });
        page.drawText("Created On: " + d.toString(), {
          x: margin + logoDims.width + 10,
          y: pageHeight - margin - 30,
          size: 10,
        });
      } catch (error) {
        console.error("Error embedding logo:", error);
        page.drawText("EduAid generated Quiz", {
          x: margin,
          y: pageHeight - margin,
          size: 20,
        });
        page.drawText("Created On: " + d.toString(), {
          x: margin,
          y: pageHeight - margin - 30,
          size: 10,
        });
      }
    }

    const form = pdfDoc.getForm();
    let y = pageHeight - margin - 70;
    let questionIndex = 1;

    const createNewPageIfNeeded = (requiredHeight) => {
      if (y - requiredHeight < margin) {
        page = pdfDoc.addPage([pageWidth, pageHeight]);
        y = pageHeight - margin;
        return true;
      }
      return false;
    };

    const wrapText = (text, maxWidth) => {
      const words = text.split(" ");
      const lines = [];
      let currentLine = "";

      words.forEach((word) => {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const testWidth = testLine.length * 6;
        if (testWidth > maxWidth) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      });

      if (currentLine) {
        lines.push(currentLine);
      }

      return lines;
    };

    qaPairs.forEach((qaPair) => {
      let requiredHeight = 60;
      const questionLines = wrapText(qaPair.question, maxContentWidth);
      requiredHeight += questionLines.length * 20;

      if (mode !== "answers") {
        if (qaPair.question_type === "Boolean") {
          requiredHeight += 60;
        } else if (
          qaPair.question_type === "MCQ" ||
          qaPair.question_type === "MCQ_Hard"
        ) {
          const optionsCount = qaPair.options ? qaPair.options.length + 1 : 1;
          requiredHeight += optionsCount * 25;
        } else {
          requiredHeight += 40;
        }
      }

      if (mode === "answers" || mode === "questions_answers") {
        requiredHeight += 40;
      }

      createNewPageIfNeeded(requiredHeight);

      if (mode !== "answers") {
        questionLines.forEach((line, lineIndex) => {
          const textToDraw =
            lineIndex === 0
              ? `Q${questionIndex}) ${line}`
              : `        ${line}`;
          page.drawText(textToDraw, {
            x: margin,
            y: y - lineIndex * 20,
            size: 12,
            maxWidth: maxContentWidth,
          });
        });
        y -= questionLines.length * 20 + 20;

        if (mode === "questions") {
          if (qaPair.question_type === "Boolean") {
            const radioGroup = form.createRadioGroup(
              `question${questionIndex}_answer`
            );
            ["True", "False"].forEach((option) => {
              const radioOptions = {
                x: margin + 20,
                y,
                width: 15,
                height: 15,
              };
              radioGroup.addOptionToPage(option, page, radioOptions);
              page.drawText(option, { x: margin + 40, y: y + 2, size: 12 });
              y -= 20;
            });
          } else if (
            qaPair.question_type === "MCQ" ||
            qaPair.question_type === "MCQ_Hard"
          ) {
            const allOptions = [...(qaPair.options || [])];
            if (qaPair.answer && !allOptions.includes(qaPair.answer)) {
              allOptions.push(qaPair.answer);
            }
            const shuffledOptions = shuffleArray([...allOptions]);

            const radioGroup = form.createRadioGroup(
              `question${questionIndex}_answer`
            );
            shuffledOptions.forEach((option, index) => {
              const radioOptions = {
                x: margin + 20,
                y,
                width: 15,
                height: 15,
              };
              radioGroup.addOptionToPage(`option${index}`, page, radioOptions);
              const optionLines = wrapText(option, maxContentWidth - 60);
              optionLines.forEach((line, lineIndex) => {
                page.drawText(line, {
                  x: margin + 40,
                  y: y + 2 - lineIndex * 15,
                  size: 12,
                });
              });
              y -= Math.max(25, optionLines.length * 20);
            });
          } else if (qaPair.question_type === "Short") {
            const answerField = form.createTextField(
              `question${questionIndex}_answer`
            );
            answerField.setText("");
            answerField.addToPage(page, {
              x: margin,
              y: y - 20,
              width: maxContentWidth,
              height: 20,
            });
            y -= 40;
          }
        }
      }

      if (mode === "answers" || mode === "questions_answers") {
        const answerText = `Answer ${questionIndex}: ${qaPair.answer}`;
        const answerLines = wrapText(answerText, maxContentWidth);
        answerLines.forEach((line, lineIndex) => {
          page.drawText(line, {
            x: margin,
            y: y - lineIndex * 15,
            size: 12,
            color: rgb(0, 0.5, 0),
          });
        });
        y -= answerLines.length * 20;
      }

      y -= 20;
      questionIndex += 1;
    });

    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "generated_questions.pdf";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    document.getElementById("pdfDropdown").classList.add("hidden");
  };

  // New function to export quiz to Canvas
  const generateCanvasQuiz = async () => {
    const { courseId, title, description } = canvasForm;
    if (!courseId) {
      setExportStatus("Please enter a Canvas Course ID.");
      return;
    }
  
    setExportStatus("Exporting to Canvas...");
    try {
      const response = await fetch(`${process.env.REACT_APP_BASE_URL}/export/canvas`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          course_id: courseId,
          quiz: {
            title,
            description,
            questions: qaPairs,
          },
        }),
      });
      const result = await response.json();
      if (response.ok) {
        setExportStatus("Success! Quiz exported:");
      setQuizUrl(result.url);
        window.open(result.url, "_blank");
      } else {
        setExportStatus(`Error: ${result.error}`);
      }
    } catch (error) {
      setExportStatus("Failed to connect to server.");
      console.error("Canvas export error:", error);
    }
  };

  return (
    <div className="w-full bg-[#02000F] flex justify-center items-center font-sans">
      <div className="w-full max-w-4xl h-full bg-opacity-50 bg-custom-gradient rounded-xl shadow-lg flex flex-col p-6">
        {/* Header */}
        <a href="/" className="flex items-center gap-2">
          <img src={logo} alt="logo" className="w-14" />
          <div className="text-3xl font-extrabold">
            <span className="bg-gradient-to-r from-[#FF005C] to-[#7600F2] text-transparent bg-clip-text">Edu</span>
            <span className="bg-gradient-to-r from-[#7600F2] to-[#00CBE7] text-transparent bg-clip-text">Aid</span>
          </div>
        </a>
  
        {/* Title */}
        <h2 className="font-bold text-2xl text-white mt-4 mb-6">Generated Questions</h2>
  
        {/* Questions List */}
        <div className="flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-gray-900">
          {qaPairs.map((qaPair, index) => {
            const combinedOptions = qaPair.options ? [...qaPair.options, qaPair.answer] : [qaPair.answer];
            const shuffledOptions = shuffleArray(combinedOptions);
            return (
              <div key={index} className="bg-[#d9d9d90d] border border-gray-800 rounded-lg p-4 mb-3">
                <p className="text-[#E4E4E4] text-sm">Question {index + 1}</p>
                <p className="text-[#FFF4F4] text-lg my-1">{qaPair.question}</p>
                {qaPair.question_type !== "Boolean" && (
                  <>
                    <p className="text-[#E4E4E4] text-sm">Answer</p>
                    <p className="text-[#FFF4F4] text-base">{qaPair.answer}</p>
                    {qaPair.options && qaPair.options.length > 0 && (
                      <div className="mt-2">
                        {shuffledOptions.map((option, idx) => (
                          <p key={idx} className="text-[#FFF4F4] text-base">
                            <span className="text-[#E4E4E4] text-sm">Option {idx + 1}: </span>{option}
                          </p>
                        ))}
                      </div>
                    )}
                  </>
                )}
              </div>
            );
          })}
        </div>
  
        {/* Action Buttons */}
        <div className="mt-6 flex flex-col items-center gap-6">
          {/* Google Form and PDF Buttons */}
          <div className="flex gap-4 flex-wrap justify-center">
            <button
              onClick={generateGoogleForm}
              className="bg-[#518E8E] text-white font-semibold px-6 py-2 rounded-lg hover:bg-[#3e706e] transition-colors"
            >
              Generate Google Form
            </button>
            <div className="relative">
              <button
                onClick={() => document.getElementById("pdfDropdown").classList.toggle("hidden")}
                className="bg-[#518E8E] text-white font-semibold px-6 py-2 rounded-lg hover:bg-[#3e706e] transition-colors"
              >
                Generate PDF
              </button>
              <div
                id="pdfDropdown"
                className="hidden absolute bottom-full mb-2 w-48 bg-[#1a1a2e] text-white rounded-lg shadow-lg z-10"
              >
                <button
                  onClick={() => generatePDF("questions")}
                  className="block w-full text-left px-4 py-2 hover:bg-[#2e2e4a] rounded-t-lg transition-colors"
                >
                  Questions Only
                </button>
                <button
                  onClick={() => generatePDF("questions_answers")}
                  className="block w-full text-left px-4 py-2 hover:bg-[#2e2e4a] transition-colors"
                >
                  Questions with Answers
                </button>
                <button
                  onClick={() => generatePDF("answers")}
                  className="block w-full text-left px-4 py-2 hover:bg-[#2e2e4a] rounded-b-lg transition-colors"
                >
                  Answers Only
                </button>
              </div>
            </div>
          </div>
  
          {/* Canvas Export Section */}
          <div className="w-full max-w-md bg-[#1a1a2e] p-4 rounded-lg">
            <h3 className="text-white font-semibold mb-3">Export to Canvas</h3>
            <div className="space-y-4">
              <div>
                <label className="text-[#E4E4E4] text-sm">Course ID</label>
                <input
                  type="text"
                  name="courseId"
                  value={canvasForm.courseId}
                  onChange={handleCanvasFormChange}
                  placeholder="Enter Canvas Course ID"
                  className="w-full bg-[#3e5063] text-white rounded-lg p-2 mt-1 outline-none focus:ring-2 focus:ring-[#518E8E]"
                />
              </div>
              <div>
                <label className="text-[#E4E4E4] text-sm">Quiz Title</label>
                <input
                  type="text"
                  name="title"
                  value={canvasForm.title}
                  onChange={handleCanvasFormChange}
                  placeholder="Enter quiz title"
                  className="w-full bg-[#3e5063] text-white rounded-lg p-2 mt-1 outline-none focus:ring-2 focus:ring-[#518E8E]"
                />
              </div>
              <div>
                <label className="text-[#E4E4E4] text-sm">Description</label>
                <textarea
                  name="description"
                  value={canvasForm.description}
                  onChange={handleCanvasFormChange}
                  placeholder="Enter quiz description"
                  className="w-full bg-[#3e5063] text-white rounded-lg p-2 mt-1 outline-none focus:ring-2 focus:ring-[#518E8E] resize-none h-20"
                />
              </div>
              <button
                onClick={generateCanvasQuiz}
                className="w-full bg-[#518E8E] text-white font-semibold px-6 py-2 rounded-lg hover:bg-[#3e706e] transition-colors"
              >
                Generate Canvas Quiz
              </button>
              {exportStatus && (
  <p className={`text-sm ${exportStatus.includes("Success") ? "text-green-400" : "text-red-400"}`}>
    {exportStatus}{" "}
    {quizUrl && (
      <a
        href={quizUrl}
        target="_blank"
        rel="noopener noreferrer"
        className="underline"
      >
        {quizUrl}
      </a>
    )}
  </p>
)}

            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Output;